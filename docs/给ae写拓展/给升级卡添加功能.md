---
layout: default
title: 给升级卡添加功能
parent: 给ae写拓展
nav_order: 6
---

# 给升级卡添加功能


功能是定时判断 所有有这张新内存卡的ae接口, 循环所有样板, 判断数量, 发送合成请求

**考虑定时器怎么加**

首先我们需要判断卡是否在me接口里面, 然后判断 me接口是否在ae网络里面, 这个网络是否通电了等

假如身上有100张卡,哪岂不是得100个定时器一直在不断判断, 就算每一组卡一个定时器. 结论就是定时器不可能加在卡上



那只能加在ae接口上, 按我的理解ae本来就有输出接口, 接口还能设置速度卡, 那就肯定会有任务定时执行机制来处理

只要找到这个机制,应该就很方便了.



所以最终通过ai 和 努力, 找到 一个IGridTickable, 由名字可以看出是grid(ae网络)的定时任务

发现这个类在存储总线等方块上被使用, 去看存储总线的实现看起来是定时刷新, 基本可以判断就是这个类



类有一个注释说是Implement on IGridHosts  which want to use AE's Network Ticking Feature.

那就ctrl H看继承关系, 直接展开所有, 发现大部分常用ae机器都是IGridProxyable下的tile类

发现大部分都是tile, 是block特有的, 也就是说只能绑定在block上, 不能绑定在 卡上, 到底是不是呢 , 我选择问ai

得到的结果是肯定




现在的问题是我没有方块只有一个升级卡, 那就只能创建一个

先创建一个白板方块, 给他的tileentity加上IGridTickable, 怎么加呢

IGridTickable一个方法返回AENetworkProxy这个类, 通过ai可以知道这个类可以帮我们解决连接ae网络的所有问题

发现IGridTickable有几个看起来是通用实现类, 那就只能问ai, 然后一个一个试了

试出来AENetworkTile好使, 方块直接连接进了ae网络, 现象是导线的变化





**扫描所有ae接口**

扫描怎么扫, 肯定是通过ae网络获取所有ae接口, ae肯定自带这个功能, 就好像人需要呼吸一样理所当然

ae网络的接口是IGrid, 里面有一个方法getMachines, 一看就知道有戏, 进游戏 打断点

你会看发现整个网络的的所有机器, 以class为key set为value



grid.getMachines(TileInterface.class)我们拿到了所有ae接口

现在就要判断每个接口是否含有我们这张新卡



**判断是否插有新卡**

这一步倒是简单, 因为之前mixin实现插入新卡的时候, 已经对升级卡这块的逻辑有一定了解

知道DualityInterface是关键类, 找这个类发现 getInventoryByName("upgrades") 可以获得4个升级槽位数据

循环一遍判断就能知道是否有新卡了, 有新卡就要扫描所有样板进行合成发送了



**读取样板数据**

这里肯定是先通过id 找到物品的class, 然后分析nbt组成结构 从中提取合成信息

这里有一坑就是 空白样板和 编码样板的 两个物品id不一样, 一下子没反应过来被恶心了好一会

空白样板 到 有编码样板 之间的转换流程  被封装得妈都不认得隐藏起来了

最后发现是ItemEncodedPattern, 这个类就那么几个方法, 很容易知道 关键方法是 getPatternForItem

~~~java
//stacks是所有合成配方的输出, stackInSlot是合成卡用来获取需要保持的数量
protected void tick(IGrid grid, IAEItemStack[] stacks, ItemStack stackInSlot) {

//ae网络的合成管理类
ICraftingGrid crafting = (ICraftingGrid) grid.getCache(ICraftingGrid.class);
//ae网络的存储类
IMEMonitor<IAEItemStack> storageGrid = ((IStorageGrid) grid.getCache(IStorageGrid.class)).getInventory(AEApi.instance().storage().getStorageChannel(IItemStorageChannel.class));
for (IAEItemStack stack : stacks) {
    //获取数量, ae特有的stack IAEItemStack, 数量没有64限制
    IAEItemStack storage = storageGrid.getStorageList().findPrecise(stack);
    //计算需要合成多少物品
    int keepNum = ItemKeeperUpgrade.getKeepNum(stackInSlot);
    long storageNumber = storage.getStackSize();
    long shouldCraft = Math.max(0, keepNum - storageNumber);
    if (shouldCraft == 0) continue;
    IAEItemStack copy = stack.copy();
    copy.setStackSize(shouldCraft);
    //合成封装, 其实还是grid的使用
    this.craftingTracker.requestCrafting(copy, world, grid, crafting, this.actionSource);
}
~~~

上面就是发送请求的逻辑了, 至于是怎么知道这样操作的, 只能说都是围绕grid, 打个断点把grid的方法变量都研究一下就知道了

研究的是时候会知道tile缺一个接口ICraftingRequester ,实现这个接口才能发送合成请求



**结束**

流程已经结束, 看起来并不算很复杂. 但我学的时候理清思路也花了不少时间

而且整个逻辑还有很大优化空间

写的思考流程和我学的时候实际流程相差甚远, 可以说是过来人复习的时候发现了更好的方法

特别是ai的胡编乱造给我带来不少麻烦
